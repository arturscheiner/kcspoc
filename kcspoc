#!/bin/bash

# ==============================================================================
# Script: kcspoc.sh
# Description: CLI tool for Kaspersky Container Security PoC management.
#              Provides interactive configuration, environment checking, and preparation.
# Environment: Linux (Ubuntu/Debian preferred), K8s
# ==============================================================================

set -e

# --- CONSTANTS & COLORS ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

CONFIG_DIR="$HOME/.kcspoc"
CONFIG_FILE="$CONFIG_DIR/config"

# --- HELPER FUNCTIONS ---

print_header() {
    echo -e "${BLUE}=== Kaspersky Container Security PoC Tool ===${NC}"
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        # echo -e "${GREEN}Configuration loaded from $CONFIG_FILE${NC}"
    else
        return 1
    fi
}

cmd_usage() {
    print_header
    echo -e "Usage: $(basename "$0") [command] [options]"
    echo ""
    echo "Commands:"
    echo "  config   Run interactive configuration wizard"
    echo "  check    Verify environment and prerequisites"
    echo "  prepare  Run the installation preparation (requires config)"
    echo "  help     Show this help message"
    exit 0
}

# --- COMMANDS ---

cmd_config() {
    print_header
    echo -e "${YELLOW}Starting Configuration Wizard...${NC}"
    echo "This wizard will help you configure the necessary variables for the KCS installation."
    echo ""

    mkdir -p "$CONFIG_DIR"

    # 1. Namespace
    echo -e "${BLUE}[1/4] K8s Namespace${NC}"
    echo "This is the Kubernetes namespace where KCS will be installed."
    echo "Default: kcs"
    echo -ne "Enter Namespace [kcs]: "
    read -r IN_NAMESPACE
    NAMESPACE=${IN_NAMESPACE:-"kcs"}

    # 2. Domain
    echo -e "\n${BLUE}[2/4] Domain Name${NC}"
    echo "The base domain for the KCS console and services."
    echo "Example: kcs.cluster.lab"
    echo "Default: kcs.cluster.lab"
    echo -ne "Enter Domain [kcs.cluster.lab]: "
    read -r IN_DOMAIN
    DOMAIN=${IN_DOMAIN:-"kcs.cluster.lab"}

    # 3. Registry Credentials
    echo -e "\n${BLUE}[3/4] Registry Credentials${NC}"
    echo "Credentials to access the private registry container images."
    
    echo -ne "Registry Server URL [registry.k8s.io]: "
    read -r IN_REGISTRY_SERVER
    REGISTRY_SERVER=${IN_REGISTRY_SERVER:-"registry.k8s.io"}
    
    echo -ne "Registry Username: "
    read -r REGISTRY_USER
    
    echo -ne "Registry Password: "
    # Read password silently
    stty -echo
    read -r REGISTRY_PASS
    stty echo
    echo ""
    
    echo -ne "Registry Email: "
    read -r REGISTRY_EMAIL

    # 4. MetalLB IP Range
    echo -e "\n${BLUE}[4/4] MetalLB IP Range${NC}"
    echo "MetalLB needs a range of IPs from your local network to assign to the LoadBalancer."
    echo "This allows you to access the KCS web console."
    echo "Example: 172.16.3.200-172.16.3.210"
    echo "Why? Without this, services stay in <Pending> state."
    echo -ne "Enter IP Range: "
    read -r IP_RANGE

    # Save to file
    cat > "$CONFIG_FILE" <<EOF
# KCS PoC Configuration
# Generated on $(date)

NAMESPACE="$NAMESPACE"
DOMAIN="$DOMAIN"

# Registry
REGISTRY_SERVER="$REGISTRY_SERVER"
REGISTRY_USER="$REGISTRY_USER"
REGISTRY_PASS="$REGISTRY_PASS"
REGISTRY_EMAIL="$REGISTRY_EMAIL"

# Networking
IP_RANGE="$IP_RANGE"
EOF

    echo -e "\n${GREEN}Configuration saved successfully to $CONFIG_FILE${NC}"
}

cmd_check() {
    print_header
    echo -e "${YELLOW}Checking Environment...${NC}"

    local ERROR=0

    # Check 1: Tools
    echo -ne "Checking CLI tools... "
    MISSING_TOOLS=""
    for tool in kubectl helm; do
        if ! command -v $tool &> /dev/null; then
            MISSING_TOOLS="$MISSING_TOOLS $tool"
        fi
    done

    if [ -n "$MISSING_TOOLS" ]; then
        echo -e "${RED}FAIL${NC}"
        echo -e "${RED}Missing required tools:$MISSING_TOOLS${NC}"
        ERROR=1
    else
        echo -e "${GREEN}OK${NC}"
    fi

    # Check 2: Config
    echo -ne "Checking Configuration... "
    if load_config; then
        if [ -z "$NAMESPACE" ] || [ -z "$IP_RANGE" ] || [ -z "$REGISTRY_USER" ]; then
             echo -e "${RED}FAIL (Missing variables in config)${NC}"
             echo "Run '$0 config' to fix this."
             ERROR=1
        else
            echo -e "${GREEN}OK${NC} (Loaded from ~/.kcspoc/config)"
        fi
    else
        echo -e "${RED}FAIL (Config file not found)${NC}"
        echo "Run '$0 config' to create it."
        ERROR=1
    fi

    # Check 3: Cluster Context & Connectivity
    echo -ne "Checking Cluster Connectivity... "
    
    # Display Current Context
    if command -v kubectl &> /dev/null; then
        CURRENT_CTX=$(kubectl config current-context 2>/dev/null || echo "None")
        echo -e "\n${BLUE}Target Cluster Context: ${YELLOW}${CURRENT_CTX}${NC}"
        echo -e "The KCS installation will target this cluster."
    fi

    echo -ne "Verifying connectivity... "
    if kubectl get nodes &> /dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        echo -e "Could not connect to Kubernetes cluster ${YELLOW}${CURRENT_CTX}${NC} using current kubeconfig."
        ERROR=1
        return 1
    fi

    # Check 4: Cluster Resources & Topology
    echo -e "\n${YELLOW}=== Cluster Resources & Topology ===${NC}"
    
    echo -ne "Gathering node information... "
    
    # Node Counts
    TOTAL_NODES=$(kubectl get nodes --no-headers | wc -l)
    MASTERS=$(kubectl get nodes --no-headers | grep -E "control-plane|master" | wc -l)
    WORKERS=$((TOTAL_NODES - MASTERS))
    
    echo -e "Done"
    echo -e "Total Nodes: ${BLUE}$TOTAL_NODES${NC} (Masters: $MASTERS, Workers: $WORKERS)"
    echo -e "\n${BLUE}Node List:${NC}"
    kubectl get nodes -o custom-columns=NAME:.metadata.name,ROLE:.metadata.labels."kubernetes\.io/role",VERSION:.status.nodeInfo.kubeletVersion,KERNEL:.status.nodeInfo.kernelVersion,OS:.status.nodeInfo.osImage
    
    echo -e "\n${YELLOW}Resource Validation (Min Requirements: 4 vCPU, 8GB RAM, Kernel 5.4)${NC}"
    
    # CPU Check (Sum of all nodes)
    # CPU capacity usually in integer or 'm'. 
    # Simplification: Assume integer for simplicity or parse 'm'. 
    # Using awk to sum.
    TOTAL_CPU=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.cpu}{"\n"}{end}' | awk '{s+=$1} END {print s}')
    # Prepare display
    if [ "$TOTAL_CPU" -ge 4 ]; then
        echo -e "CPU (Total): ${GREEN}${TOTAL_CPU} vCPUs${NC} (PASS)"
    else
        echo -e "CPU (Total): ${RED}${TOTAL_CPU} vCPUs${NC} (FAIL - Min 4)"
        ERROR=1
    fi

    # RAM Check (Sum of all nodes)
    # Memory usually in Ki. 1GB ~ 1000000Ki or 1048576Ki. 
    # Minimum 8GB = ~8000000Ki
    TOTAL_MEM_KI=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.memory}{"\n"}{end}' | sed 's/Ki//g' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_GB=$((TOTAL_MEM_KI / 1024 / 1024))
    
    if [ "$TOTAL_MEM_GB" -ge 8 ]; then
        echo -e "RAM (Total): ${GREEN}~${TOTAL_MEM_GB} GB${NC} (PASS)"
    else
        echo -e "RAM (Total): ${RED}~${TOTAL_MEM_GB} GB${NC} (FAIL - Min 8 GB)"
        ERROR=1
    fi
    
    # Kernel Version Check (Min 5.4)
    # We check each node.
    echo -e "Kernel Versions:"
    kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}: {.status.nodeInfo.kernelVersion}{"\n"}{end}' | while read -r node_kernel; do
        # Extract version number X.Y
        KVER=$(echo "$node_kernel" | awk '{print $2}' | cut -d'-' -f1)
        MAJOR=$(echo "$KVER" | cut -d. -f1)
        MINOR=$(echo "$KVER" | cut -d. -f2)
        
        # Simple check 5.4
        if [ "$MAJOR" -gt 5 ] || { [ "$MAJOR" -eq 5 ] && [ "$MINOR" -ge 4 ]; }; then
             echo -e "  - $node_kernel ${GREEN}(PASS)${NC}"
        else
             echo -e "  - $node_kernel ${RED}(FAIL - Min 5.4)${NC}"
             ERROR=1
        fi
    done

    # Disk Space Warning (Manual Check hint as requested or simple parsing)
    # The user asked for "kubectl describe nodes" command validation.
    # Showing capacity of ephemeral-storage as proxy or just list it.
    echo -e "\n${BLUE}Disk Capacity (Ephemeral Storage):${NC}"
    kubectl get nodes -o custom-columns=NAME:.metadata.name,DISK:.status.capacity.ephemeral-storage
    echo -e "${YELLOW}Note: Check if 'DISK' meets 80GB req per node manually if unsure.${NC}"



    if [ $ERROR -eq 0 ]; then
        echo -e "\n${GREEN}All checks passed. You are ready to run '$0 prepare'.${NC}"
    else
        echo -e "\n${RED}Checks failed. Please address the issues above.${NC}"
        exit 1
    fi
}

cmd_prepare() {
    print_header
    
    # Load config first
    if ! load_config; then
        echo -e "${RED}Error: Configuration not found. Please run '$0 config' first.${NC}"
        exit 1
    fi

    echo -e "${BLUE}=== Starting Preparation ===${NC}"
    echo "Using Namespace: $NAMESPACE"
    echo "Using Domain: $DOMAIN"
    echo "Using IP Range: $IP_RANGE"
    echo "----------------------------"

    # 1. Namespace & Secret
    echo -e "${YELLOW}[1/6] Configuring Namespace and Registry Auth...${NC}"
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    
    echo "Creating registry secret..."
    kubectl create secret docker-registry kcs-registry-secret \
      --docker-server="$REGISTRY_SERVER" \
      --docker-username="$REGISTRY_USER" \
      --docker-password="$REGISTRY_PASS" \
      --docker-email="$REGISTRY_EMAIL" \
      -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

    # 2. Infrastructure Dependencies
    echo -e "${YELLOW}[2/6] Installing Infrastructure Dependencies...${NC}"
    
    # Cert-Manager
    echo "Installing Cert-Manager..."
    helm repo add jetstack https://charts.jetstack.io --force-update > /dev/null
    helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --set crds.enabled=true --wait > /dev/null

    # Local Path Storage
    echo "Installing Local Path Provisioner..."
    kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.31/deploy/local-path-storage.yaml > /dev/null
    kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

    # Metrics Server
    echo "Installing Metrics Server..."
    kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml > /dev/null
    # Patch for lab environments (insecure TLS)
    kubectl patch deployment metrics-server -n kube-system --type='json' -p='[
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"},
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-preferred-address-types=InternalIP"}
    ]' 2>/dev/null || true

    # 3. MetalLB
    echo -e "${YELLOW}[3/6] Configuring MetalLB...${NC}"
    helm repo add metallb https://metallb.github.io/metallb > /dev/null
    helm upgrade --install metallb metallb/metallb --namespace metallb-system --create-namespace --wait > /dev/null
    
    sleep 5
    
    cat <<EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: first-pool
  namespace: metallb-system
spec:
  addresses:
  - $IP_RANGE
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-adv
  namespace: metallb-system
EOF

    # 4. Ingress-Nginx
    echo -e "${YELLOW}[4/6] Installing Ingress-Nginx...${NC}"
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx > /dev/null
    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --wait > /dev/null

    # 5. Kernel Headers
    echo -e "${YELLOW}[5/6] Installing Kernel Headers...${NC}"
    # Check if we have sudo
    if command -v sudo > /dev/null; then
        sudo apt update && sudo apt install linux-headers-$(uname -r) -y
    else
        echo -e "${RED}sudo not found, skipping kernel headers install.${NC}"
    fi

    # 6. Verification
    echo -e "${YELLOW}[6/6] Final Verification...${NC}"
    sleep 5
    INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

    echo -e "${GREEN}=== Setup Completed! ===${NC}"
    echo -e "Ingress IP: $INGRESS_IP"
    echo -e "Add this to your /etc/hosts: $INGRESS_IP $DOMAIN"
}

# --- MAIN ---

case "$1" in
    config)
        cmd_config
        ;;
    check)
        cmd_check
        ;;
    prepare)
        cmd_prepare
        ;;
    help|*)
        cmd_usage
        ;;
esac
