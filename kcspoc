#!/bin/bash

# ==============================================================================
# Script: kcspoc.sh
# Description: CLI tool for Kaspersky Container Security PoC management.
#              Provides interactive configuration, environment checking, and preparation.
# Environment: Linux (Ubuntu/Debian preferred), K8s
# ==============================================================================

set -e

# --- CONSTANTS & COLORS ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

CONFIG_DIR="$HOME/.kcspoc"
CONFIG_FILE="$CONFIG_DIR/config"

# --- HELPER FUNCTIONS ---

print_header() {
    echo -e "${BLUE}=== Kaspersky Container Security PoC Tool ===${NC}"
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        # echo -e "${GREEN}Configuration loaded from $CONFIG_FILE${NC}"
    else
        return 1
    fi
}

cmd_usage() {
    print_header
    echo -e "Usage: $(basename "$0") [command] [options]"
    echo ""
    echo "Commands:"
    echo "  config   Run interactive configuration wizard"
    echo "  check    Verify environment and prerequisites"
    echo "  prepare  Run the installation preparation (requires config)"
    echo "  help     Show this help message"
    exit 0
}

# --- COMMANDS ---

cmd_config() {
    print_header
    echo -e "${YELLOW}Starting Configuration Wizard...${NC}"
    echo "This wizard will help you configure the necessary variables for the KCS installation."
    echo ""

    mkdir -p "$CONFIG_DIR"
    
    # Load existing config to use as defaults
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        echo -e "${GREEN}Loaded existing configuration as defaults.${NC}"
    fi

    # 1. Namespace
    DEFAULT_NS=${NAMESPACE:-"kcs"}
    echo -e "${BLUE}[1/5] K8s Namespace${NC}"
    echo "This is the Kubernetes namespace where KCS will be installed."
    echo "Default: $DEFAULT_NS"
    echo -ne "Enter Namespace [$DEFAULT_NS]: "
    read -r IN_NAMESPACE
    NAMESPACE=${IN_NAMESPACE:-$DEFAULT_NS}

    # 2. Domain
    DEFAULT_DOMAIN=${DOMAIN:-"kcs.cluster.lab"}
    echo -e "\n${BLUE}[2/5] Domain Name${NC}"
    echo "The base domain for the KCS console and services."
    echo "Default: $DEFAULT_DOMAIN"
    echo -ne "Enter Domain [$DEFAULT_DOMAIN]: "
    read -r IN_DOMAIN
    DOMAIN=${IN_DOMAIN:-$DEFAULT_DOMAIN}

    # 3. Registry Credentials
    DEFAULT_REG_SERVER=${REGISTRY_SERVER:-"registry.k8s.io"}
    echo -e "\n${BLUE}[3/5] Registry Credentials${NC}"
    echo "Credentials to access the private registry container images."
    
    echo -ne "Registry Server URL [$DEFAULT_REG_SERVER]: "
    read -r IN_REGISTRY_SERVER
    REGISTRY_SERVER=${IN_REGISTRY_SERVER:-$DEFAULT_REG_SERVER}
    
    DEFAULT_REG_USER=${REGISTRY_USER}
    echo -ne "Registry Username${DEFAULT_REG_USER:+ [$DEFAULT_REG_USER]}: "
    read -r IN_REGISTRY_USER
    REGISTRY_USER=${IN_REGISTRY_USER:-$DEFAULT_REG_USER}
    
    echo -ne "Registry Password (leave empty to keep existing or enter new): "
    # Read password silently
    stty -echo
    read -r IN_REGISTRY_PASS
    stty echo
    echo ""
    if [ -n "$IN_REGISTRY_PASS" ]; then
        REGISTRY_PASS="$IN_REGISTRY_PASS"
    fi
    #(If empty, keeps $REGISTRY_PASS from loaded config)
    
    DEFAULT_REG_EMAIL=${REGISTRY_EMAIL}
    echo -ne "Registry Email${DEFAULT_REG_EMAIL:+ [$DEFAULT_REG_EMAIL]}: "
    read -r IN_REGISTRY_EMAIL
    REGISTRY_EMAIL=${IN_REGISTRY_EMAIL:-$DEFAULT_REG_EMAIL}

    # 4. MetalLB IP Range
    DEFAULT_IP_RANGE=${IP_RANGE}
    echo -e "\n${BLUE}[4/5] MetalLB IP Range${NC}"
    echo "MetalLB needs a range of IPs from your local network to assign to the LoadBalancer."
    echo "Example: 172.16.3.200-172.16.3.210"
    if [ -n "$DEFAULT_IP_RANGE" ]; then echo "Current: $DEFAULT_IP_RANGE"; fi
    echo -ne "Enter IP Range${DEFAULT_IP_RANGE:+ [$DEFAULT_IP_RANGE]}: "
    read -r IN_IP_RANGE
    IP_RANGE=${IN_IP_RANGE:-$DEFAULT_IP_RANGE}

    # 5. Deep Inspection Permission
    DEFAULT_DEEP=${ENABLE_DEEP_CHECK:-"false"}
    echo -e "\n${BLUE}[5/5] Deep Node Inspection${NC}"
    echo "To verify disk space and kernel headers accurately, we can run a temporary privileged pod on each node."
    echo "Current: $DEFAULT_DEEP"
    echo -ne "Allow deep packet inspection? [y/N]: "
    read -r IN_DEEP
    
    if [ -z "$IN_DEEP" ]; then
        # Keep existing if user just hints enter? Or default to N if not set?
        # Standard input behavior: empty input usually means default.
        # If we have a previous value, we should respect it effectively.
        ENABLE_DEEP_CHECK=$DEFAULT_DEEP
    else
        if [[ "$IN_DEEP" =~ ^[Yy]$ ]]; then
            ENABLE_DEEP_CHECK="true"
        else
            ENABLE_DEEP_CHECK="false"
        fi
    fi

    # Save to file
    cat > "$CONFIG_FILE" <<EOF
# KCS PoC Configuration
# Generated on $(date)

NAMESPACE="$NAMESPACE"
DOMAIN="$DOMAIN"

# Registry
REGISTRY_SERVER="$REGISTRY_SERVER"
REGISTRY_USER="$REGISTRY_USER"
REGISTRY_PASS="$REGISTRY_PASS"
REGISTRY_EMAIL="$REGISTRY_EMAIL"

# Networking
IP_RANGE="$IP_RANGE"

# Checks
ENABLE_DEEP_CHECK="$ENABLE_DEEP_CHECK"
EOF

    echo -e "\n${GREEN}Configuration saved successfully to $CONFIG_FILE${NC}"
}

cmd_check() {
    print_header
    echo -e "${YELLOW}Checking Environment...${NC}"

    local ERROR=0

    # Check 1: Tools
    echo -ne "Checking CLI tools... "
    MISSING_TOOLS=""
    for tool in kubectl helm; do
        if ! command -v $tool &> /dev/null; then
            MISSING_TOOLS="$MISSING_TOOLS $tool"
        fi
    done

    if [ -n "$MISSING_TOOLS" ]; then
        echo -e "${RED}FAIL${NC}"
        echo -e "${RED}Missing required tools:$MISSING_TOOLS${NC}"
        ERROR=1
    else
        echo -e "${GREEN}OK${NC}"
    fi

    # Check 2: Config
    echo -ne "Checking Configuration... "
    if load_config; then
        if [ -z "$NAMESPACE" ] || [ -z "$IP_RANGE" ] || [ -z "$REGISTRY_USER" ]; then
             echo -e "${RED}FAIL (Missing variables in config)${NC}"
             echo "Run '$0 config' to fix this."
             ERROR=1
        else
            echo -e "${GREEN}OK${NC} (Loaded from ~/.kcspoc/config)"
        fi
    else
        echo -e "${RED}FAIL (Config file not found)${NC}"
        echo "Run '$0 config' to create it."
        ERROR=1
    fi

    # Check 3: Cluster Context & Connectivity
    echo -ne "Checking Cluster Connectivity... "
    
    # Display Current Context
    if command -v kubectl &> /dev/null; then
        CURRENT_CTX=$(kubectl config current-context 2>/dev/null || echo "None")
        echo -e "\n${BLUE}Target Cluster Context: ${YELLOW}${CURRENT_CTX}${NC}"
        echo -e "The KCS installation will target this cluster."
    fi

    echo -ne "Verifying connectivity... "
    if kubectl get nodes &> /dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        echo -e "Could not connect to Kubernetes cluster ${YELLOW}${CURRENT_CTX}${NC} using current kubeconfig."
        ERROR=1
        return 1
    fi

    # Check 4: Cluster Resources & Topology
    echo -e "\n${YELLOW}=== Cluster Resources & Topology ===${NC}"
    
    # --- 4.1 Kubernetes Version Check ---
    echo -ne "Checking Kubernetes Version... "
    # Get server version (gitVersion)
    K8S_VER_STR=$(kubectl version -o json 2>/dev/null | grep gitVersion | grep -v Client | head -n 1 | awk -F'"' '{print $4}')
    if [ -z "$K8S_VER_STR" ]; then
        K8S_VER_STR=$(kubectl get nodes -o jsonpath='{.items[0].status.nodeInfo.kubeletVersion}')
    fi
    VER_CLEAN=$(echo "$K8S_VER_STR" | sed 's/v//')
    MAJOR=$(echo "$VER_CLEAN" | cut -d. -f1)
    MINOR=$(echo "$VER_CLEAN" | cut -d. -f2)

    if [ "$MAJOR" -eq 1 ] && [ "$MINOR" -ge 25 ] && [ "$MINOR" -le 34 ]; then
         echo -e "${GREEN}${K8S_VER_STR}${NC} (Pass: 1.25 <= v <= 1.34)"
    else
         echo -e "${RED}${K8S_VER_STR}${NC} (FAIL: Supported range 1.25 - 1.34)"
         ERROR=1
    fi

    # --- 4.2 Architecture Check ---
    echo -ne "Checking Architecture... "
    # Suportado: Apenas amd64 (x86_64).
    ARCH_COUNT=$(kubectl get nodes -o jsonpath='{.items[*].status.nodeInfo.architecture}' | tr ' ' '\n' | sort | uniq -c)
    if echo "$ARCH_COUNT" | grep -q "amd64"; then
         # Check if ONLY amd64
         if [ $(echo "$ARCH_COUNT" | wc -l) -eq 1 ]; then
             echo -e "${GREEN}amd64${NC} (Pass)"
         else
             echo -e "${YELLOW}Mixed Architectures detected${NC} (Warning: Core only supports amd64)"
         fi
    else
         echo -e "${RED}No amd64 nodes found${NC} (FAIL)"
         ERROR=1
    fi

    # --- 4.3 Container Runtime Check ---
    echo -ne "Checking Container Runtime... "
    # Suportados: Containerd (1.6+), CRI-O (1.24+).
    # Format typically: containerd://1.6.20 or cri-o://1.24.1
    RUNTIMES=$(kubectl get nodes -o jsonpath='{.items[*].status.nodeInfo.containerRuntimeVersion}' | tr ' ' '\n' | sort | uniq)
    echo -e "${BLUE}$RUNTIMES${NC}"
    
    for rt in $RUNTIMES; do
        # Extract name and version
        RT_NAME=$(echo "$rt" | awk -F'://' '{print $1}')
        RT_VER=$(echo "$rt" | awk -F'://' '{print $2}')
        
        # Version comparison helper
        check_ver() {
             local ver=$1
             local min=$2
             if [ "$(printf '%s\n' "$min" "$ver" | sort -V | head -n1)" = "$min" ]; then echo "ok"; else echo "fail"; fi
        }

        if [[ "$RT_NAME" == "containerd" ]]; then
             if [ "$(check_ver "$RT_VER" "1.6")" == "ok" ]; then
                 echo -e "  - containerd $RT_VER ${GREEN}(OK - 1.6+)${NC}"
             else
                 echo -e "  - containerd $RT_VER ${RED}(FAIL - Min 1.6)${NC}"
                 ERROR=1
             fi
        elif [[ "$RT_NAME" == "cri-o" ]]; then
             if [ "$(check_ver "$RT_VER" "1.24")" == "ok" ]; then
                  echo -e "  - cri-o $RT_VER ${GREEN}(OK - 1.24+)${NC}"
             else
                  echo -e "  - cri-o $RT_VER ${RED}(FAIL - Min 1.24)${NC}"
                  ERROR=1
             fi
        elif [[ "$RT_NAME" == "docker" ]]; then
             echo -e "  - docker ${YELLOW}(Warning: Deprecated. Ensure KCS compatibility)${NC}"
        else
             echo -e "  - $rt ${YELLOW}(Unknown/Untested)${NC}"
        fi
    done
    
    # --- 4.4 CNI Plugin Check ---
    echo -ne "Checking CNI Plugin... "
    # Check for common CNI pods in Running state
    CNI_PODS=$(kubectl get pods -A --no-headers | grep -E "calico|flannel|cilium|weave|antrea|kube-proxy" | grep "Running" || true)
    
    if [ -n "$CNI_PODS" ]; then
        # Extract unique CNI names for display
        CNI_NAMES=$(echo "$CNI_PODS" | awk '{print $2}' | grep -oE "calico|flannel|cilium|weave|antrea" | sort | uniq | tr '\n' ' ')
        if [ -z "$CNI_NAMES" ]; then CNI_NAMES="kube-proxy (Standard)"; fi
        
        echo -e "${GREEN}OK${NC} (Detected: $CNI_NAMES)"
    else
        echo -e "${YELLOW}Warning: No common CNI pods (Calico, Flannel, Cilium) detected in Running state.${NC}"
        # Not a hard fail as customized CNI might have different names, but warning is strict.
    fi

    # --- 4.4 Node Resources & Deep Inspection ---
    echo -e "\n${BLUE}Node Resources (CPU / RAM / Disk / Kernel Headers):${NC}"
    
    if [[ "$ENABLE_DEEP_CHECK" == "true" ]]; then
        echo -e "${YELLOW}Running Deep Node Inspection (Privileged Pods)...${NC}"
    else
        echo -e "${YELLOW}(Deep Check Disabled: Basic info only. Templates saved to $CONFIG_DIR)${NC}"
    fi
    
    # Unified Table Header
    printf "%-30s %-15s %-10s %-15s %-15s %-20s\n" "NODE" "ROLE" "CPU" "RAM" "DISK(Root)" "HEADERS"
    echo "-----------------------------------------------------------------------------------------------------------------"

    # Get list of nodes names only
    # Loop one by one to avoid alignment issues with missing fields in bulk jsonpath
    for name in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        
        # 1. Fetch Node Details
        # Role: Check labels for control-plane or master
        # CPU/Mem: Get capacity
        # We use a single jsonpath call to get cpu and memory to minimize calls.
        # Let's get raw json or multiple fields with delimiter ' | '
        
        node_info=$(kubectl get node "$name" -o jsonpath='{.metadata.labels}|{.status.capacity.cpu}|{.status.capacity.memory}')
        
        # Parse output: labels|cpu|memory
        IFS='|' read -r labels cpu mem_raw <<< "$node_info"
        unset IFS
        
        # Determine Role
        if [[ "$labels" == *"node-role.kubernetes.io/control-plane"* ]] || [[ "$labels" == *"node-role.kubernetes.io/master"* ]]; then
            role="control-plane"
        else
            role="worker"
        fi
        
        # Basic Math: RAM
        MEM_KB=$(echo "$mem_raw" | sed 's/[^0-9]*//g')
        if [[ "$mem_raw" == *"Mi"* ]]; then MEM_GB=$((MEM_KB / 1024)); elif [[ "$mem_raw" == *"Gi"* ]]; then MEM_GB=$MEM_KB; else MEM_GB=$((MEM_KB / 1024 / 1024)); fi
        
        # --- GENERATE DEBUG TEMPLATE (ALWAYS) ---
        POD_FILE="$CONFIG_DIR/debug-node-${name}.yaml"
        cat <<EOF > "$POD_FILE"
apiVersion: v1
kind: Pod
metadata:
  name: debug-node-${name}
  namespace: default
spec:
  hostPID: true
  hostIPC: true
  hostNetwork: true
  nodeName: ${name}
  restartPolicy: Never
  containers:
  - name: debug-container
    image: ubuntu:latest
    command: ["sleep", "infinity"]
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /host
      name: host-volume
  volumes:
  - name: host-volume
    hostPath:
      path: /
  terminationGracePeriodSeconds: 1
EOF

        # --- DEEP INSPECTION EXECUTION ---
        if [[ "$ENABLE_DEEP_CHECK" == "true" ]]; then
            # Apply and Wait
            kubectl apply -f "$POD_FILE" &> /dev/null
            
            # Wait loop (kubectl wait sometimes fails if pod is not immediately seen)
            sleep 2
            if ! kubectl wait --for=condition=Ready pod/debug-node-${name} --timeout=40s &> /dev/null; then
                # If timed out or failed
                DISK_AVAIL="Err-Pod"
                HAS_HEADERS="Err-Pod"
            else
                # Exec Commands
                # DISK
                DISK_AVAIL=$(kubectl exec debug-node-${name} -- chroot /host df -h / | tail -n 1 | awk '{print $4}' 2>/dev/null || echo "N/A")
                
                # HEADERS
                # Validating if headers/devel packages are installed (Required for eBPF)
                if HEADERS_OUT=$(kubectl exec "debug-node-${name}" -- /bin/bash -c "chroot /host sh -c 'dpkg -l 2>/dev/null | grep -i headers || rpm -qa 2>/dev/null | grep -i headers'" 2>/dev/null); then
                     if [ -n "$HEADERS_OUT" ]; then
                         HAS_HEADERS="${GREEN}YES${NC}"
                     else
                         HAS_HEADERS="${RED}NO${NC}"
                     fi
                else
                     HAS_HEADERS="${RED}Err${NC}"
                fi
            fi

            # Cleanup Pod (BUT KEEP FILE)
            kubectl delete pod debug-node-${name} --force --grace-period=0 &> /dev/null
        else
            # Skipping execution
            DISK_AVAIL="-"
            HAS_HEADERS="-"
        fi

        # Print Row
        printf "%-30s %-15s %-10s %-15s %-15s %-20b\n" "$name" "$role" "$cpu" "${MEM_GB}G" "$DISK_AVAIL" "$HAS_HEADERS"

    done

    # --- 4.5 External Connectivity (Moved to End) ---
    echo -e "\n${BLUE}Checking Repo Connectivity (repo.kcs.kaspersky.com)...${NC}"
    if kubectl run -i --rm --image=curlimages/curl --restart=Never connectivity-test -- curl -m 5 -I https://repo.kcs.kaspersky.com &> /dev/null; then
         echo -e "${GREEN}OK${NC}"
    else
         echo -e "${RED}FAIL${NC} (Could not reach repo.kcs.kaspersky.com)"
         ERROR=1
    fi

    # Global Requirements Summary (Totals)
    TOTAL_CPU=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.cpu}{"\n"}{end}' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_KI=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.memory}{"\n"}{end}' | sed 's/Ki//g' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_GB=$((TOTAL_MEM_KI / 1024 / 1024))
    
    echo -e "\n${YELLOW}Global Cluster Totals:${NC}"
    if [ "$TOTAL_CPU" -ge 4 ]; then echo -e "CPU: ${GREEN}${TOTAL_CPU} vCPUs${NC} (Pass)"; else echo -e "CPU: ${RED}${TOTAL_CPU} vCPUs${NC} (FAIL)"; ERROR=1; fi
    if [ "$TOTAL_MEM_GB" -ge 8 ]; then echo -e "RAM: ${GREEN}~${TOTAL_MEM_GB} GB${NC} (Pass)"; else echo -e "RAM: ${RED}~${TOTAL_MEM_GB} GB${NC} (FAIL)"; ERROR=1; fi



    if [ $ERROR -eq 0 ]; then
        echo -e "\n${GREEN}All checks passed. You are ready to run '$0 prepare'.${NC}"
    else
        echo -e "\n${RED}Checks failed. Please address the issues above.${NC}"
        exit 1
    fi
}

cmd_prepare() {
    print_header
    
    # Load config first
    if ! load_config; then
        echo -e "${RED}Error: Configuration not found. Please run '$0 config' first.${NC}"
        exit 1
    fi

    echo -e "${BLUE}=== Starting Preparation ===${NC}"
    echo "Using Namespace: $NAMESPACE"
    echo "Using Domain: $DOMAIN"
    echo "Using IP Range: $IP_RANGE"
    echo "----------------------------"

    # 1. Namespace & Secret
    echo -e "${YELLOW}[1/6] Configuring Namespace and Registry Auth...${NC}"
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    
    echo "Creating registry secret..."
    kubectl create secret docker-registry kcs-registry-secret \
      --docker-server="$REGISTRY_SERVER" \
      --docker-username="$REGISTRY_USER" \
      --docker-password="$REGISTRY_PASS" \
      --docker-email="$REGISTRY_EMAIL" \
      -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

    # 2. Infrastructure Dependencies
    echo -e "${YELLOW}[2/6] Installing Infrastructure Dependencies...${NC}"
    
    # Cert-Manager
    echo "Installing Cert-Manager..."
    helm repo add jetstack https://charts.jetstack.io --force-update > /dev/null
    helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --set crds.enabled=true --wait > /dev/null

    # Local Path Storage
    echo "Installing Local Path Provisioner..."
    kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.31/deploy/local-path-storage.yaml > /dev/null
    kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

    # Metrics Server
    echo "Installing Metrics Server..."
    kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml > /dev/null
    # Patch for lab environments (insecure TLS)
    kubectl patch deployment metrics-server -n kube-system --type='json' -p='[
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"},
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-preferred-address-types=InternalIP"}
    ]' 2>/dev/null || true

    # 3. MetalLB
    echo -e "${YELLOW}[3/6] Configuring MetalLB...${NC}"
    helm repo add metallb https://metallb.github.io/metallb > /dev/null
    helm upgrade --install metallb metallb/metallb --namespace metallb-system --create-namespace --wait > /dev/null
    
    sleep 5
    
    cat <<EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: first-pool
  namespace: metallb-system
spec:
  addresses:
  - $IP_RANGE
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-adv
  namespace: metallb-system
EOF

    # 4. Ingress-Nginx
    echo -e "${YELLOW}[4/6] Installing Ingress-Nginx...${NC}"
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx > /dev/null
    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --wait > /dev/null

    # 5. Kernel Headers
    echo -e "${YELLOW}[5/6] Installing Kernel Headers...${NC}"
    # Check if we have sudo
    if command -v sudo > /dev/null; then
        sudo apt update && sudo apt install linux-headers-$(uname -r) -y
    else
        echo -e "${RED}sudo not found, skipping kernel headers install.${NC}"
    fi

    # 6. Verification
    echo -e "${YELLOW}[6/6] Final Verification...${NC}"
    sleep 5
    INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

    echo -e "${GREEN}=== Setup Completed! ===${NC}"
    echo -e "Ingress IP: $INGRESS_IP"
    echo -e "Add this to your /etc/hosts: $INGRESS_IP $DOMAIN"
}

# --- MAIN ---

case "$1" in
    config)
        cmd_config
        ;;
    check)
        cmd_check
        ;;
    prepare)
        cmd_prepare
        ;;
    help|*)
        cmd_usage
        ;;
esac
