#!/bin/bash

# ==============================================================================
# Script: kcspoc.sh
# Description: CLI tool for Kaspersky Container Security PoC management.
#              Provides interactive configuration, environment checking, and preparation.
# Environment: Linux (Ubuntu/Debian preferred), K8s
# ==============================================================================

set -e

# --- CONSTANTS & COLORS ---
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'

CONFIG_DIR="$HOME/.kcspoc"
CONFIG_FILE="$CONFIG_DIR/config"

# --- HELPER FUNCTIONS ---

print_header() {
    echo -e "${BLUE}=== Kaspersky Container Security PoC Tool ===${NC}"
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        # echo -e "${GREEN}Configuration loaded from $CONFIG_FILE${NC}"
    else
        return 1
    fi
}

cmd_usage() {
    print_header
    echo -e "Usage: $(basename "$0") [command] [options]"
    echo ""
    echo "Commands:"
    echo "  config   Run interactive configuration wizard"
    echo "  check    Verify environment and prerequisites"
    echo "  prepare  Run the installation preparation (requires config)"
    echo "  help     Show this help message"
    exit 0
}

# --- COMMANDS ---

cmd_config() {
    print_header
    echo -e "${YELLOW}Starting Configuration Wizard...${NC}"
    echo "This wizard will help you configure the necessary variables for the KCS installation."
    echo ""

    mkdir -p "$CONFIG_DIR"

    # 1. Namespace
    echo -e "${BLUE}[1/4] K8s Namespace${NC}"
    echo "This is the Kubernetes namespace where KCS will be installed."
    echo "Default: kcs"
    echo -ne "Enter Namespace [kcs]: "
    read -r IN_NAMESPACE
    NAMESPACE=${IN_NAMESPACE:-"kcs"}

    # 2. Domain
    echo -e "\n${BLUE}[2/4] Domain Name${NC}"
    echo "The base domain for the KCS console and services."
    echo "Example: kcs.cluster.lab"
    echo "Default: kcs.cluster.lab"
    echo -ne "Enter Domain [kcs.cluster.lab]: "
    read -r IN_DOMAIN
    DOMAIN=${IN_DOMAIN:-"kcs.cluster.lab"}

    # 3. Registry Credentials
    echo -e "\n${BLUE}[3/4] Registry Credentials${NC}"
    echo "Credentials to access the private registry container images."
    
    echo -ne "Registry Server URL [registry.k8s.io]: "
    read -r IN_REGISTRY_SERVER
    REGISTRY_SERVER=${IN_REGISTRY_SERVER:-"registry.k8s.io"}
    
    echo -ne "Registry Username: "
    read -r REGISTRY_USER
    
    echo -ne "Registry Password: "
    # Read password silently
    stty -echo
    read -r REGISTRY_PASS
    stty echo
    echo ""
    
    echo -ne "Registry Email: "
    read -r REGISTRY_EMAIL

    # 4. MetalLB IP Range
    echo -e "\n${BLUE}[4/4] MetalLB IP Range${NC}"
    echo "MetalLB needs a range of IPs from your local network to assign to the LoadBalancer."
    echo "This allows you to access the KCS web console."
    echo "Example: 172.16.3.200-172.16.3.210"
    echo "Why? Without this, services stay in <Pending> state."
    echo -ne "Enter IP Range: "
    read -r IP_RANGE

    # Save to file
    cat > "$CONFIG_FILE" <<EOF
# KCS PoC Configuration
# Generated on $(date)

NAMESPACE="$NAMESPACE"
DOMAIN="$DOMAIN"

# Registry
REGISTRY_SERVER="$REGISTRY_SERVER"
REGISTRY_USER="$REGISTRY_USER"
REGISTRY_PASS="$REGISTRY_PASS"
REGISTRY_EMAIL="$REGISTRY_EMAIL"

# Networking
IP_RANGE="$IP_RANGE"
EOF

    echo -e "\n${GREEN}Configuration saved successfully to $CONFIG_FILE${NC}"
}

cmd_check() {
    print_header
    echo -e "${YELLOW}Checking Environment...${NC}"

    local ERROR=0

    # Check 1: Tools
    echo -ne "Checking CLI tools... "
    MISSING_TOOLS=""
    for tool in kubectl helm; do
        if ! command -v $tool &> /dev/null; then
            MISSING_TOOLS="$MISSING_TOOLS $tool"
        fi
    done

    if [ -n "$MISSING_TOOLS" ]; then
        echo -e "${RED}FAIL${NC}"
        echo -e "${RED}Missing required tools:$MISSING_TOOLS${NC}"
        ERROR=1
    else
        echo -e "${GREEN}OK${NC}"
    fi

    # Check 2: Config
    echo -ne "Checking Configuration... "
    if load_config; then
        if [ -z "$NAMESPACE" ] || [ -z "$IP_RANGE" ] || [ -z "$REGISTRY_USER" ]; then
             echo -e "${RED}FAIL (Missing variables in config)${NC}"
             echo "Run '$0 config' to fix this."
             ERROR=1
        else
            echo -e "${GREEN}OK${NC} (Loaded from ~/.kcspoc/config)"
        fi
    else
        echo -e "${RED}FAIL (Config file not found)${NC}"
        echo "Run '$0 config' to create it."
        ERROR=1
    fi

    # Check 3: Cluster Context & Connectivity
    echo -ne "Checking Cluster Connectivity... "
    
    # Display Current Context
    if command -v kubectl &> /dev/null; then
        CURRENT_CTX=$(kubectl config current-context 2>/dev/null || echo "None")
        echo -e "\n${BLUE}Target Cluster Context: ${YELLOW}${CURRENT_CTX}${NC}"
        echo -e "The KCS installation will target this cluster."
    fi

    echo -ne "Verifying connectivity... "
    if kubectl get nodes &> /dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        echo -e "Could not connect to Kubernetes cluster ${YELLOW}${CURRENT_CTX}${NC} using current kubeconfig."
        ERROR=1
        return 1
    fi

    # Check 4: Cluster Resources & Topology
    echo -e "\n${YELLOW}=== Cluster Resources & Topology ===${NC}"
    
    # 4.1 Kubernetes Version Check
    echo -ne "Checking Kubernetes Version... "
    # Get server version (gitVersion) e.g., v1.28.3
    K8S_VER_STR=$(kubectl version -o json 2>/dev/null | grep gitVersion | grep -v Client | head -n 1 | awk -F'"' '{print $4}')
    
    # Fallback to 'kubectl version --short' parsing if json fails (older cli)
    if [ -z "$K8S_VER_STR" ]; then
        K8S_VER_STR=$(kubectl get nodes -o jsonpath='{.items[0].status.nodeInfo.kubeletVersion}')
    fi

    # Extract Major.Minor e.g., 1.28
    # Remove 'v' prefix if present
    VER_CLEAN=$(echo "$K8S_VER_STR" | sed 's/v//')
    MAJOR=$(echo "$VER_CLEAN" | cut -d. -f1)
    MINOR=$(echo "$VER_CLEAN" | cut -d. -f2)

    # Check Range: Min 1.25, Max 1.34
    if [ "$MAJOR" -eq 1 ] && [ "$MINOR" -ge 25 ] && [ "$MINOR" -le 34 ]; then
         echo -e "${GREEN}${K8S_VER_STR}${NC} (Pass: 1.25 <= v <= 1.34)"
    else
         echo -e "${RED}${K8S_VER_STR}${NC} (FAIL: Supported range 1.25 - 1.34)"
         ERROR=1
    fi

    # 4.2 Per-Node Resource Stats
    echo -e "\n${BLUE}Node Resources (CPU / RAM / Ephemeral Storage):${NC}"
    printf "%-20s %-15s %-15s %-15s %-15s\n" "NODE" "ROLE" "CPU" "RAM (GB)" "DISK (GB)"
    echo "--------------------------------------------------------------------------------"

    # Iterate over nodes to calculate and display values
    # We use jsonpath to get one line per node with needed fields
    kubectl get nodes -o jsonpath='{range .items[*]}{.metadata.name}{" "}{.metadata.labels.kubernetes\.io/role}{" "}{.status.capacity.cpu}{" "}{.status.capacity.memory}{" "}{.status.capacity.ephemeral-storage}{"\n"}{end}' | while read -r name role cpu mem_raw disk_raw; do
        
        # Handle Role (if label is missing, it might be empty or <none>)
        # Some setups use node-role.kubernetes.io/control-plane type labels instead of value
        # Simple fallback checks:
        if [[ "$role" == "" ]]; then
            # try finding role in labels via grep
            if kubectl get node "$name" --show-labels | grep -q "control-plane"; then role="control-plane"; else role="worker"; fi
        fi

        # MEM: Convert Ki to GB. 1 GiB = 1024^2 KiB? usually input is Ki. 
        # 1000000 Ki ~= 1GB approx. Let's do rough math: val / 1024 / 1024
        MEM_KB=$(echo "$mem_raw" | sed 's/[^0-9]*//g') # Remove units
        if [[ "$mem_raw" == *"Mi"* ]]; then
             MEM_GB=$((MEM_KB / 1024))
        elif [[ "$mem_raw" == *"Gi"* ]]; then
             MEM_GB=$MEM_KB
        else 
             # Assume Ki
             MEM_GB=$((MEM_KB / 1024 / 1024))
        fi

        # DISK: Convert to GB. Usually Bytes or Ki.
        DISK_VAL=$(echo "$disk_raw" | sed 's/[^0-9]*//g')
        if [[ "$disk_raw" == *"Ki"* ]]; then
            DISK_GB=$((DISK_VAL / 1024 / 1024))
        elif [[ "$disk_raw" == *"Mi"* ]]; then
            DISK_GB=$((DISK_VAL / 1024))
        elif [[ "$disk_raw" == *"Gi"* ]]; then
            DISK_GB=$DISK_VAL
        else
            # Assume bytes
            DISK_GB=$((DISK_VAL / 1024 / 1024 / 1024))
        fi
        
        # Formatting
        printf "%-20s %-15s %-15s %-15s %-15s\n" "$name" "$role" "$cpu" "~${MEM_GB}G" "~${DISK_GB}G"
        
        # Min Requirements Check Per Node (Optional strictly enforcement or just informative? Request implied showing info)
        # We'll just display for now, global checks were done before vs totals, but user wants per node info.
    done

    echo -e "\n${YELLOW}Global Requirements Check (Lab: 4vCPU, 8GB RAM Total)${NC}"
    
    # Calculate Totals for Pass/Fail
    TOTAL_CPU=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.cpu}{"\n"}{end}' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_KI=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.memory}{"\n"}{end}' | sed 's/Ki//g' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_GB=$((TOTAL_MEM_KI / 1024 / 1024))
    
    if [ "$TOTAL_CPU" -ge 4 ]; then echo -e "Cluster CPU: ${GREEN}${TOTAL_CPU} vCPUs${NC} (OK)"; else echo -e "Cluster CPU: ${RED}${TOTAL_CPU} vCPUs${NC} (FAIL)"; ERROR=1; fi
    if [ "$TOTAL_MEM_GB" -ge 8 ]; then echo -e "Cluster RAM: ${GREEN}~${TOTAL_MEM_GB} GB${NC} (OK)"; else echo -e "Cluster RAM: ${RED}~${TOTAL_MEM_GB} GB${NC} (FAIL)"; ERROR=1; fi



    if [ $ERROR -eq 0 ]; then
        echo -e "\n${GREEN}All checks passed. You are ready to run '$0 prepare'.${NC}"
    else
        echo -e "\n${RED}Checks failed. Please address the issues above.${NC}"
        exit 1
    fi
}

cmd_prepare() {
    print_header
    
    # Load config first
    if ! load_config; then
        echo -e "${RED}Error: Configuration not found. Please run '$0 config' first.${NC}"
        exit 1
    fi

    echo -e "${BLUE}=== Starting Preparation ===${NC}"
    echo "Using Namespace: $NAMESPACE"
    echo "Using Domain: $DOMAIN"
    echo "Using IP Range: $IP_RANGE"
    echo "----------------------------"

    # 1. Namespace & Secret
    echo -e "${YELLOW}[1/6] Configuring Namespace and Registry Auth...${NC}"
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    
    echo "Creating registry secret..."
    kubectl create secret docker-registry kcs-registry-secret \
      --docker-server="$REGISTRY_SERVER" \
      --docker-username="$REGISTRY_USER" \
      --docker-password="$REGISTRY_PASS" \
      --docker-email="$REGISTRY_EMAIL" \
      -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

    # 2. Infrastructure Dependencies
    echo -e "${YELLOW}[2/6] Installing Infrastructure Dependencies...${NC}"
    
    # Cert-Manager
    echo "Installing Cert-Manager..."
    helm repo add jetstack https://charts.jetstack.io --force-update > /dev/null
    helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --set crds.enabled=true --wait > /dev/null

    # Local Path Storage
    echo "Installing Local Path Provisioner..."
    kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.31/deploy/local-path-storage.yaml > /dev/null
    kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

    # Metrics Server
    echo "Installing Metrics Server..."
    kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml > /dev/null
    # Patch for lab environments (insecure TLS)
    kubectl patch deployment metrics-server -n kube-system --type='json' -p='[
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"},
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-preferred-address-types=InternalIP"}
    ]' 2>/dev/null || true

    # 3. MetalLB
    echo -e "${YELLOW}[3/6] Configuring MetalLB...${NC}"
    helm repo add metallb https://metallb.github.io/metallb > /dev/null
    helm upgrade --install metallb metallb/metallb --namespace metallb-system --create-namespace --wait > /dev/null
    
    sleep 5
    
    cat <<EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: first-pool
  namespace: metallb-system
spec:
  addresses:
  - $IP_RANGE
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-adv
  namespace: metallb-system
EOF

    # 4. Ingress-Nginx
    echo -e "${YELLOW}[4/6] Installing Ingress-Nginx...${NC}"
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx > /dev/null
    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --wait > /dev/null

    # 5. Kernel Headers
    echo -e "${YELLOW}[5/6] Installing Kernel Headers...${NC}"
    # Check if we have sudo
    if command -v sudo > /dev/null; then
        sudo apt update && sudo apt install linux-headers-$(uname -r) -y
    else
        echo -e "${RED}sudo not found, skipping kernel headers install.${NC}"
    fi

    # 6. Verification
    echo -e "${YELLOW}[6/6] Final Verification...${NC}"
    sleep 5
    INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

    echo -e "${GREEN}=== Setup Completed! ===${NC}"
    echo -e "Ingress IP: $INGRESS_IP"
    echo -e "Add this to your /etc/hosts: $INGRESS_IP $DOMAIN"
}

# --- MAIN ---

case "$1" in
    config)
        cmd_config
        ;;
    check)
        cmd_check
        ;;
    prepare)
        cmd_prepare
        ;;
    help|*)
        cmd_usage
        ;;
esac
