#!/bin/bash

# ==============================================================================
# Script: kcspoc.sh
# Description: CLI tool for Kaspersky Container Security PoC management.
#              Provides interactive configuration, environment checking, and preparation.
# Environment: Linux (Ubuntu/Debian preferred), K8s
# ==============================================================================

set -e

# --- VISUAL IDENTITY & CONSTANTS ---
# Colors
BOLD='\033[1m'
DIM='\033[2m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# Icons
ICON_OK="✔"
ICON_FAIL="✘"
ICON_INFO="ℹ"
ICON_WARN="⚠"
ICON_QUESTION="?"
ICON_ARROW="➜"
ICON_GEAR="⚙"

CONFIG_DIR="$HOME/.kcspoc"
CONFIG_FILE="$CONFIG_DIR/config"

# --- HELPER FUNCTIONS ---

ui_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    echo "  _  __ _____ ____  ____   ___   _____"
    echo " | |/ // ____/ ___||  _ \ / _ \ / ____|"
    echo " | ' /| |    \___ \| |_) | | | | |     "
    echo " |  < | |     ___) |  __/| |_| | |     "
    echo " |_|\_\\_____|____/|_|    \___/ \_____|"
    echo -e "${NC}"
    echo -e "${DIM}  Kaspersky Container Security - Proof of Concept Tool${NC}"
    echo -e "${BLUE}  ====================================================${NC}"
    echo -e "${DIM}  Version: 0.1.0${NC}"
    echo -e "${DIM}  Author: Arturs Scheiner${NC}"
    echo ""
}

ui_section() {
    local title="$1"
    echo -e "${MAGENTA}${BOLD}:: ${title} ::${NC}"
    echo -e "${DIM}------------------------------------------------------${NC}"
}

ui_step() {
    local current="$1"
    local total="$2"
    local title="$3"
    local desc="$4"
    echo -e "\n${BOLD}[${current}/${total}] ${title}${NC}"
    if [ -n "$desc" ]; then
        echo -e "${DIM}   ${desc}${NC}"
    fi
}

ui_input() {
    local label="$1"
    local default_val="$2"
    local current_val="$3"
    local is_secret="$4"
    
    echo -ne "   ${ICON_ARROW} ${label}"
    
    # Display logic: If current exists and is different from default, show both?
    # Visual: Label (Default: X) [Current: Y] :
    
    if [ -n "$default_val" ]; then
        echo -ne " ${DIM}(Default: ${default_val})${NC}"
    fi
    
    # If no current value, we use default as the 'prompt' hint
    local prompt_val="${current_val:-$default_val}"
    
    echo -ne " ${CYAN}[${prompt_val}]${NC}: "
    
    if [ "$is_secret" == "yes" ]; then
        stty -echo
        read -r user_in
        stty echo
        echo ""
    else
        read -r user_in
    fi
    
    if [ -z "$user_in" ]; then
        RET_VAL="$prompt_val"
    else
        RET_VAL="$user_in"
    fi
}

load_config() {
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        return 0
    else
        return 1
    fi
}

cmd_usage() {
    ui_banner
    echo -e "${BOLD}Usage:${NC} $(basename "$0") [command] [options]"
    echo ""
    echo -e "${BOLD}Commands:${NC}"
    echo -e "  ${GREEN}config${NC}   Run interactive configuration wizard"
    echo -e "  ${GREEN}pull${NC}     Download KCS chart (usage: pull [--version X.X.X])"
    echo -e "  ${GREEN}check${NC}    Verify environment and prerequisites"
    echo -e "  ${GREEN}prepare${NC}  Run the installation preparation (requires config)"
    echo -e "  ${GREEN}help${NC}     Show this help message"
    exit 0
}

# --- COMMANDS ---

cmd_config() {
    ui_banner
    ui_section "Configuration Wizard"
    echo -e "This wizard generates the ${YELLOW}~/.kcspoc/config${NC} file."
    echo ""

    mkdir -p "$CONFIG_DIR"
    
    # Load existing config to show as "Current"
    local CUR_NS="" CUR_DOMAIN="" CUR_REG_SRV="" CUR_REG_USER="" CUR_REG_EMAIL="" CUR_IP_RANGE="" CUR_DEEP="" CUR_VER=""
    
    if [ -f "$CONFIG_FILE" ]; then
        source "$CONFIG_FILE"
        CUR_NS="$NAMESPACE"
        CUR_DOMAIN="$DOMAIN"
        CUR_REG_SRV="$REGISTRY_SERVER"
        CUR_REG_USER="$REGISTRY_USER"
        CUR_REG_EMAIL="$REGISTRY_EMAIL"
        CUR_IP_RANGE="$IP_RANGE"
        CUR_DEEP="$ENABLE_DEEP_CHECK"
        CUR_VER="$KCS_VERSION"
        echo -e "${GREEN}${ICON_OK} Loaded existing configuration.${NC}"
    fi

    # 1. Namespace
    ui_step 1 6 "Kubernetes Namespace" "Where KCS resources will be created."
    ui_input "Namespace" "kcs" "$CUR_NS"
    NAMESPACE="$RET_VAL"

    # 2. Domain
    ui_step 2 6 "Base Domain" "Domain for KCS console/services (e.g. kcs.lab)."
    ui_input "Domain" "kcs.cluster.lab" "$CUR_DOMAIN"
    DOMAIN="$RET_VAL"

    # 3. Registry
    ui_step 3 6 "Registry Credentials" "Access to KCS container images."
    
    ui_input "Server URL" "repo.kcs.kaspersky.com" "$CUR_REG_SRV"
    REGISTRY_SERVER="$RET_VAL"
    
    ui_input "Username" "" "$CUR_REG_USER"
    REGISTRY_USER="$RET_VAL"
    
    ui_input "Password" "" "****" "yes"
    # If user hit enter (empty) and we had a previous password (**** aka set), keep old param
    # But wait, ui_input returns prompt_val if empty. If prompt_val was ****, we don't want to save ****.
    if [ "$RET_VAL" == "****" ]; then
         REGISTRY_PASS="$REGISTRY_PASS" # Keep existing global variable
    else
         REGISTRY_PASS="$RET_VAL"
    fi
    
    ui_input "Email" "" "$CUR_REG_EMAIL"
    REGISTRY_EMAIL="$RET_VAL"

    # 4. MetalLB
    ui_step 4 6 "MetalLB IP Range" "Range for LoadBalancer (e.g. 172.16.0.10-172.16.0.20)"
    ui_input "IP Range" "" "$CUR_IP_RANGE"
    IP_RANGE="$RET_VAL"

    # 5. Deep Check
    ui_step 5 6 "Deep Node Inspection" "Run privileged pods to check disk/headers?"
    ui_input "Enable Deep Check? (true/false)" "false" "$CUR_DEEP"
    ENABLE_DEEP_CHECK="$RET_VAL"

    # 6. Version
    ui_step 6 6 "KCS Version" "Target version to install."
    ui_input "Version" "latest" "$CUR_VER"
    KCS_VERSION="$RET_VAL"

    # Save
    cat > "$CONFIG_FILE" <<EOF
# KCS PoC Configuration
# Generated on $(date)

NAMESPACE="$NAMESPACE"
DOMAIN="$DOMAIN"

# Registry
REGISTRY_SERVER="$REGISTRY_SERVER"
REGISTRY_USER="$REGISTRY_USER"
REGISTRY_PASS="$REGISTRY_PASS"
REGISTRY_EMAIL="$REGISTRY_EMAIL"

# Networking
IP_RANGE="$IP_RANGE"

# Installation
KCS_VERSION="$KCS_VERSION"

# Checks
ENABLE_DEEP_CHECK="$ENABLE_DEEP_CHECK"
EOF
    
    echo -e "\n${GREEN}${ICON_OK} Configuration saved to $CONFIG_FILE${NC}"
    echo -e "${DIM}You can now run 'kcspoc pull' or 'kcspoc check'.${NC}"
}

cmd_check() {
    print_header
    echo -e "${YELLOW}Checking Environment...${NC}"

    local ERROR=0

    # Check 1: Tools
    echo -ne "Checking CLI tools... "
    MISSING_TOOLS=""
    for tool in kubectl helm; do
        if ! command -v $tool &> /dev/null; then
            MISSING_TOOLS="$MISSING_TOOLS $tool"
        fi
    done

    if [ -n "$MISSING_TOOLS" ]; then
        echo -e "${RED}FAIL${NC}"
        echo -e "${RED}Missing required tools:$MISSING_TOOLS${NC}"
        ERROR=1
    else
        echo -e "${GREEN}OK${NC}"
    fi

    # Check 2: Config
    echo -ne "Checking Configuration... "
    if load_config; then
        if [ -z "$NAMESPACE" ] || [ -z "$IP_RANGE" ] || [ -z "$REGISTRY_USER" ]; then
             echo -e "${RED}FAIL (Missing variables in config)${NC}"
             echo "Run '$0 config' to fix this."
             ERROR=1
        else
            echo -e "${GREEN}OK${NC} (Loaded from ~/.kcspoc/config)"
        fi
    else
        echo -e "${RED}FAIL (Config file not found)${NC}"
        echo "Run '$0 config' to create it."
        ERROR=1
    fi

    # Check 3: Cluster Context & Connectivity
    echo -ne "Checking Cluster Connectivity... "
    
    # Display Current Context
    if command -v kubectl &> /dev/null; then
        CURRENT_CTX=$(kubectl config current-context 2>/dev/null || echo "None")
        echo -e "\n${BLUE}Target Cluster Context: ${YELLOW}${CURRENT_CTX}${NC}"
        echo -e "The KCS installation will target this cluster."
    fi

    echo -ne "Verifying connectivity... "
    if kubectl get nodes &> /dev/null; then
        echo -e "${GREEN}OK${NC}"
    else
        echo -e "${RED}FAIL${NC}"
        echo -e "Could not connect to Kubernetes cluster ${YELLOW}${CURRENT_CTX}${NC} using current kubeconfig."
        ERROR=1
        return 1
    fi

    # Check 4: Cluster Resources & Topology
    echo -e "\n${YELLOW}=== Cluster Resources & Topology ===${NC}"
    
    # --- 4.1 Kubernetes Version Check ---
    echo -ne "Checking Kubernetes Version... "
    # Get server version (gitVersion)
    K8S_VER_STR=$(kubectl version -o json 2>/dev/null | grep gitVersion | grep -v Client | head -n 1 | awk -F'"' '{print $4}')
    if [ -z "$K8S_VER_STR" ]; then
        K8S_VER_STR=$(kubectl get nodes -o jsonpath='{.items[0].status.nodeInfo.kubeletVersion}')
    fi
    VER_CLEAN=$(echo "$K8S_VER_STR" | sed 's/v//')
    MAJOR=$(echo "$VER_CLEAN" | cut -d. -f1)
    MINOR=$(echo "$VER_CLEAN" | cut -d. -f2)

    if [ "$MAJOR" -eq 1 ] && [ "$MINOR" -ge 25 ] && [ "$MINOR" -le 34 ]; then
         echo -e "${GREEN}${K8S_VER_STR}${NC} (Pass: 1.25 <= v <= 1.34)"
    else
         echo -e "${RED}${K8S_VER_STR}${NC} (FAIL: Supported range 1.25 - 1.34)"
         ERROR=1
    fi

    # --- 4.2 Architecture Check ---
    echo -ne "Checking Architecture... "
    # Suportado: Apenas amd64 (x86_64).
    ARCH_COUNT=$(kubectl get nodes -o jsonpath='{.items[*].status.nodeInfo.architecture}' | tr ' ' '\n' | sort | uniq -c)
    if echo "$ARCH_COUNT" | grep -q "amd64"; then
         # Check if ONLY amd64
         if [ $(echo "$ARCH_COUNT" | wc -l) -eq 1 ]; then
             echo -e "${GREEN}amd64${NC} (Pass)"
         else
             echo -e "${YELLOW}Mixed Architectures detected${NC} (Warning: Core only supports amd64)"
         fi
    else
         echo -e "${RED}No amd64 nodes found${NC} (FAIL)"
         ERROR=1
    fi

    # --- 4.3 Container Runtime Check ---
    echo -ne "Checking Container Runtime... "
    # Suportados: Containerd (1.6+), CRI-O (1.24+).
    # Format typically: containerd://1.6.20 or cri-o://1.24.1
    RUNTIMES=$(kubectl get nodes -o jsonpath='{.items[*].status.nodeInfo.containerRuntimeVersion}' | tr ' ' '\n' | sort | uniq)
    echo -e "${BLUE}$RUNTIMES${NC}"
    
    for rt in $RUNTIMES; do
        # Extract name and version
        RT_NAME=$(echo "$rt" | awk -F'://' '{print $1}')
        RT_VER=$(echo "$rt" | awk -F'://' '{print $2}')
        
        # Version comparison helper
        check_ver() {
             local ver=$1
             local min=$2
             if [ "$(printf '%s\n' "$min" "$ver" | sort -V | head -n1)" = "$min" ]; then echo "ok"; else echo "fail"; fi
        }

        if [[ "$RT_NAME" == "containerd" ]]; then
             if [ "$(check_ver "$RT_VER" "1.6")" == "ok" ]; then
                 echo -e "  - containerd $RT_VER ${GREEN}(OK - 1.6+)${NC}"
             else
                 echo -e "  - containerd $RT_VER ${RED}(FAIL - Min 1.6)${NC}"
                 ERROR=1
             fi
        elif [[ "$RT_NAME" == "cri-o" ]]; then
             if [ "$(check_ver "$RT_VER" "1.24")" == "ok" ]; then
                  echo -e "  - cri-o $RT_VER ${GREEN}(OK - 1.24+)${NC}"
             else
                  echo -e "  - cri-o $RT_VER ${RED}(FAIL - Min 1.24)${NC}"
                  ERROR=1
             fi
        elif [[ "$RT_NAME" == "docker" ]]; then
             echo -e "  - docker ${YELLOW}(Warning: Deprecated. Ensure KCS compatibility)${NC}"
        else
             echo -e "  - $rt ${YELLOW}(Unknown/Untested)${NC}"
        fi
    done
    
    # --- 4.4 CNI Plugin Check ---
    echo -ne "Checking CNI Plugin... "
    # Check for common CNI pods in Running state
    CNI_PODS=$(kubectl get pods -A --no-headers | grep -E "calico|flannel|cilium|weave|antrea|kube-proxy" | grep "Running" || true)
    
    if [ -n "$CNI_PODS" ]; then
        # Extract unique CNI names for display
        CNI_NAMES=$(echo "$CNI_PODS" | awk '{print $2}' | grep -oE "calico|flannel|cilium|weave|antrea" | sort | uniq | tr '\n' ' ')
        if [ -z "$CNI_NAMES" ]; then CNI_NAMES="kube-proxy (Standard)"; fi
        
        echo -e "${GREEN}OK${NC} (Detected: $CNI_NAMES)"
    else
        echo -e "${YELLOW}Warning: No common CNI pods (Calico, Flannel, Cilium) detected in Running state.${NC}"
        # Not a hard fail as customized CNI might have different names, but warning is strict.
    fi

    # --- 4.4 Node Resources & Deep Inspection ---
    echo -e "\n${BLUE}Node Resources (CPU / RAM / Disk / Kernel Headers):${NC}"
    
    if [[ "$ENABLE_DEEP_CHECK" == "true" ]]; then
        echo -e "${YELLOW}Running Deep Node Inspection (Privileged Pods)...${NC}"
    else
        echo -e "${YELLOW}(Deep Check Disabled: Basic info only. Templates saved to $CONFIG_DIR)${NC}"
    fi
    
    # Unified Table Header
    printf "%-30s %-15s %-10s %-15s %-15s %-10s %-20s\n" "NODE" "ROLE" "CPU" "RAM" "DISK" "eBPF" "HEADERS"
    echo "----------------------------------------------------------------------------------------------------------------------------------"

    # Get list of nodes names only
    # Loop one by one to avoid alignment issues with missing fields in bulk jsonpath
    for name in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}'); do
        
        # 1. Fetch Node Details
        # Role: Check labels for control-plane or master
        # CPU/Mem: Get capacity
        # We use a single jsonpath call to get cpu and memory to minimize calls.
        # Let's get raw json or multiple fields with delimiter ' | '
        
        node_info=$(kubectl get node "$name" -o jsonpath='{.metadata.labels}|{.status.capacity.cpu}|{.status.capacity.memory}')
        
        # Parse output: labels|cpu|memory
        IFS='|' read -r labels cpu mem_raw <<< "$node_info"
        unset IFS
        
        # Determine Role
        if [[ "$labels" == *"node-role.kubernetes.io/control-plane"* ]] || [[ "$labels" == *"node-role.kubernetes.io/master"* ]]; then
            role="control-plane"
        else
            role="worker"
        fi
        
        # Basic Math: RAM
        MEM_KB=$(echo "$mem_raw" | sed 's/[^0-9]*//g')
        if [[ "$mem_raw" == *"Mi"* ]]; then MEM_GB=$((MEM_KB / 1024)); elif [[ "$mem_raw" == *"Gi"* ]]; then MEM_GB=$MEM_KB; else MEM_GB=$((MEM_KB / 1024 / 1024)); fi
        
        # --- GENERATE DEBUG TEMPLATE (ALWAYS) ---
        POD_FILE="$CONFIG_DIR/debug-node-${name}.yaml"
        cat <<EOF > "$POD_FILE"
apiVersion: v1
kind: Pod
metadata:
  name: debug-node-${name}
  namespace: default
spec:
  hostPID: true
  hostIPC: true
  hostNetwork: true
  nodeName: ${name}
  restartPolicy: Never
  containers:
  - name: debug-container
    image: ubuntu:latest
    command: ["sleep", "infinity"]
    securityContext:
      privileged: true
    volumeMounts:
    - mountPath: /host
      name: host-volume
  volumes:
  - name: host-volume
    hostPath:
      path: /
  terminationGracePeriodSeconds: 1
EOF

        # --- DEEP INSPECTION EXECUTION ---
        if [[ "$ENABLE_DEEP_CHECK" == "true" ]]; then
            # Apply and Wait
            kubectl apply -f "$POD_FILE" &> /dev/null
            
            # Wait loop (kubectl wait sometimes fails if pod is not immediately seen)
            sleep 2
            if ! kubectl wait --for=condition=Ready pod/debug-node-${name} --timeout=40s &> /dev/null; then
                # If timed out or failed
                DISK_AVAIL="Err-Pod"
                HAS_HEADERS="Err-Pod"
                HAS_EBPF="Err-Pod"
            else
                # Exec Commands
                # DISK
                DISK_AVAIL=$(kubectl exec debug-node-${name} -- chroot /host df -h / | tail -n 1 | awk '{print $4}' 2>/dev/null || echo "N/A")
                
                # eBPF (BTF) Check
                if kubectl exec debug-node-${name} -- chroot /host test -f /sys/kernel/btf/vmlinux &> /dev/null; then
                     HAS_EBPF="${GREEN}OK${NC}"
                else
                     HAS_EBPF="${RED}NO${NC}"
                fi

                # HEADERS
                # Validating if headers/devel packages are installed (Required for eBPF)
                if HEADERS_OUT=$(kubectl exec "debug-node-${name}" -- /bin/bash -c "chroot /host sh -c 'dpkg -l 2>/dev/null | grep -i headers || rpm -qa 2>/dev/null | grep -i headers'" 2>/dev/null); then
                     if [ -n "$HEADERS_OUT" ]; then
                         HAS_HEADERS="${GREEN}YES${NC}"
                     else
                         HAS_HEADERS="${RED}NO${NC}"
                     fi
                else
                     HAS_HEADERS="${RED}Err${NC}"
                fi
            fi

            # Cleanup Pod (BUT KEEP FILE)
            kubectl delete pod debug-node-${name} --force --grace-period=0 &> /dev/null
        else
            # Skipping execution
            DISK_AVAIL="-"
            HAS_HEADERS="-"
            HAS_EBPF="-"
        fi

        # Print Row
        printf "%-30s %-15s %-10s %-15s %-15s %-20b %-20b\n" "$name" "$role" "$cpu" "${MEM_GB}G" "$DISK_AVAIL" "$HAS_EBPF" "$HAS_HEADERS"

    done

    # --- 4.5 External Connectivity (Moved to End) ---
    echo -e "\n${BLUE}Checking Repo Connectivity (repo.kcs.kaspersky.com)...${NC}"
    if kubectl run -i --rm --image=curlimages/curl --restart=Never connectivity-test -- curl -m 5 -I https://repo.kcs.kaspersky.com &> /dev/null; then
         echo -e "${GREEN}OK${NC}"
    else
         echo -e "${RED}FAIL${NC} (Could not reach repo.kcs.kaspersky.com)"
         ERROR=1
    fi

    # Global Requirements Summary (Totals)
    TOTAL_CPU=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.cpu}{"\n"}{end}' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_KI=$(kubectl get nodes -o jsonpath='{range .items[*]}{.status.capacity.memory}{"\n"}{end}' | sed 's/Ki//g' | awk '{s+=$1} END {print s}')
    TOTAL_MEM_GB=$((TOTAL_MEM_KI / 1024 / 1024))
    
    echo -e "\n${YELLOW}Global Cluster Totals:${NC}"
    if [ "$TOTAL_CPU" -ge 4 ]; then echo -e "CPU: ${GREEN}${TOTAL_CPU} vCPUs${NC} (Pass)"; else echo -e "CPU: ${RED}${TOTAL_CPU} vCPUs${NC} (FAIL)"; ERROR=1; fi
    if [ "$TOTAL_MEM_GB" -ge 8 ]; then echo -e "RAM: ${GREEN}~${TOTAL_MEM_GB} GB${NC} (Pass)"; else echo -e "RAM: ${RED}~${TOTAL_MEM_GB} GB${NC} (FAIL)"; ERROR=1; fi



    if [ $ERROR -eq 0 ]; then
        echo -e "\n${GREEN}All checks passed. You are ready to run '$0 prepare'.${NC}"
    else
        echo -e "\n${RED}Checks failed. Please address the issues above.${NC}"
        exit 1
    fi
}

cmd_pull() {
    print_header
    
    # Args Parsing
    local FORCE_VERSION=""
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            --version) FORCE_VERSION="$2"; shift ;;
            *) ;;
        esac
        shift
    done

    # Load Config
    if ! load_config; then
        echo -e "${RED}Error: Configuration not found. Please run '$0 config' first.${NC}"
        exit 1
    fi
    
    echo -e "${YELLOW}=== Pulling KCS Chart ===${NC}"

    # 1. Registry Login
    echo -e "${YELLOW}Authenticating to Registry ($REGISTRY_SERVER)...${NC}"
    if echo "$REGISTRY_PASS" | helm registry login "$REGISTRY_SERVER/v2/" --username "$REGISTRY_USER" --password-stdin; then
        echo -e "${GREEN}Login Successful${NC}"
    else
        echo -e "${RED}Login Failed${NC} (Trying fallback to root path...)"
        if echo "$REGISTRY_PASS" | helm registry login "$REGISTRY_SERVER" --username "$REGISTRY_USER" --password-stdin; then
             echo -e "${GREEN}Login Successful${NC}"
        else
             echo -e "${RED}Error: Could not login to registry.${NC}"
             exit 1
        fi
    fi

    # 2. Determine Version
    # Logic: Flag > Config > "latest"
    # User Spec: "if not specified use the version of the config file"
    # "if specified only 'latest' remove the --version X.X.X"
    
    local TARGET_VER=""
    
    if [ -n "$FORCE_VERSION" ]; then
        TARGET_VER="$FORCE_VERSION"
        echo -e "Version Source: Command Flag ($TARGET_VER)"
    elif [ -n "$KCS_VERSION" ] && [ "$KCS_VERSION" != "latest" ]; then
        TARGET_VER="$KCS_VERSION"
        echo -e "Version Source: Config File ($TARGET_VER)"
    else
        TARGET_VER="latest"
        echo -e "Version Source: Default (latest)"
    fi
    
    local HELM_ARGS=""
    if [ "$TARGET_VER" != "latest" ]; then
        HELM_ARGS="--version $TARGET_VER"
    fi

    # 3. Helm Pull
    cd "$CONFIG_DIR" || exit 1
    echo -e "\n${BLUE}Downloading KCS Chart...${NC}"
    
    # Using explicit repo URL as requested
    if helm pull oci://repo.kcs.kaspersky.com/charts/kcs $HELM_ARGS; then
        echo -e "${GREEN}Download successful.${NC}"
        
        # 4. Extract
        # Identify the file. Helm saves as kcs-X.X.X.tgz
        # We sort by time to get the freshest one, or match version?
        # Freshest is safest if we just downloaded it.
        TGZ_FILE=$(ls -t kcs-*.tgz 2>/dev/null | head -n 1)
        
        if [ -f "$TGZ_FILE" ]; then
            echo "Extracting $TGZ_FILE..."
            tar -xzf "$TGZ_FILE"
            echo -e "${GREEN}Chart extracted to $CONFIG_DIR${NC}"
        else
             echo -e "${RED}Error: Downloaded file not found!${NC}"
             exit 1
        fi
    else
        echo -e "${RED}Helm pull failed.${NC}"
        exit 1
    fi
}

cmd_prepare() {
    print_header
    
    # Load config first
    if ! load_config; then
        echo -e "${RED}Error: Configuration not found. Please run '$0 config' first.${NC}"
        exit 1
    fi

    echo -e "${BLUE}=== Starting Preparation ===${NC}"
    echo "Using Namespace: $NAMESPACE"
    echo "Using Registry: $REGISTRY_SERVER"
    echo "Using Domain: $DOMAIN"
    echo "Using IP Range: $IP_RANGE"
    echo "----------------------------"

    # 0. Helm Registry Login (Moved to 'pull' command)
    # The user manual flow is now: config -> pull -> prepare -> install

    # 1. Namespace & Secret
    echo -e "${YELLOW}[1/6] Configuring Namespace and Registry Auth...${NC}"
    kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -
    
    echo "Creating registry secret..."
    kubectl create secret docker-registry kcs-registry-secret \
      --docker-server="$REGISTRY_SERVER" \
      --docker-username="$REGISTRY_USER" \
      --docker-password="$REGISTRY_PASS" \
      --docker-email="$REGISTRY_EMAIL" \
      -n "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

    # 2. Infrastructure Dependencies
    echo -e "${YELLOW}[2/6] Installing Infrastructure Dependencies...${NC}"
    
    # Cert-Manager
    echo "Installing Cert-Manager..."
    helm repo add jetstack https://charts.jetstack.io --force-update > /dev/null
    helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --set crds.enabled=true --wait > /dev/null

    # Local Path Storage
    echo "Installing Local Path Provisioner..."
    kubectl apply -f https://raw.githubusercontent.com/rancher/local-path-provisioner/v0.0.31/deploy/local-path-storage.yaml > /dev/null
    kubectl patch storageclass local-path -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"true"}}}'

    # Metrics Server
    echo "Installing Metrics Server..."
    kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml > /dev/null
    # Patch for lab environments (insecure TLS)
    kubectl patch deployment metrics-server -n kube-system --type='json' -p='[
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-insecure-tls"},
      {"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--kubelet-preferred-address-types=InternalIP"}
    ]' 2>/dev/null || true

    # 3. MetalLB
    echo -e "${YELLOW}[3/6] Configuring MetalLB...${NC}"
    helm repo add metallb https://metallb.github.io/metallb > /dev/null
    helm upgrade --install metallb metallb/metallb --namespace metallb-system --create-namespace --wait > /dev/null
    
    sleep 5
    
    cat <<EOF | kubectl apply -f -
apiVersion: metallb.io/v1beta1
kind: IPAddressPool
metadata:
  name: first-pool
  namespace: metallb-system
spec:
  addresses:
  - $IP_RANGE
---
apiVersion: metallb.io/v1beta1
kind: L2Advertisement
metadata:
  name: l2-adv
  namespace: metallb-system
EOF

    # 4. Ingress-Nginx
    echo -e "${YELLOW}[4/6] Installing Ingress-Nginx...${NC}"
    helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx > /dev/null
    helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx --namespace ingress-nginx --create-namespace --wait > /dev/null

    # 5. Kernel Headers
    echo -e "${YELLOW}[5/6] Installing Kernel Headers...${NC}"
    # Check if we have sudo
    if command -v sudo > /dev/null; then
        sudo apt update && sudo apt install linux-headers-$(uname -r) -y
    else
        echo -e "${RED}sudo not found, skipping kernel headers install.${NC}"
    fi

    # 6. Verification
    echo -e "${YELLOW}[6/6] Final Verification...${NC}"
    sleep 5
    INGRESS_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

    echo -e "${GREEN}=== Setup Completed! ===${NC}"
    echo -e "Ingress IP: $INGRESS_IP"
    echo -e "Add this to your /etc/hosts: $INGRESS_IP $DOMAIN"
}

# --- MAIN ---

case "$1" in
    config)
        cmd_config
        ;;
    pull)
        shift # Remove 'pull' from args
        cmd_pull "$@"
        ;;
    check)
        cmd_check
        ;;
    prepare)
        cmd_prepare
        ;;
    help|*)
        cmd_usage
        ;;
esac
