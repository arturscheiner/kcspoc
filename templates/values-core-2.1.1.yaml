################################################################################
# KCS EDUCATIONAL TEMPLATE - Version 2.1.1
# ------------------------------------------------------------------------------
# üéØ TARGET AUDIENCE: Pre-Sales Engineers & Architects
# ‚ö†Ô∏è ENVIRONMENT: POC / LAB ONLY (Optimized for resource-constrained nodes)
#
# üìù WHAT CHANGED IN v2.1.1?
# 1. Mandatory NetworkPolicy Path: The Chart now requires explicit ingress 
#    namespaces to prevent rendering errors.
# 2. Update Path Refactoring: Moved to $.Values.default.updates.enabled.
# 3. Identity Stability: Hardened mTLS bootstrap using 'certSource: helm'.
################################################################################

# --- [TEACHING POINT: METADATA & TRACEABILITY] ---
# Why use custom labels? To allow 'kcspoc' to track resources that Helm might
# miss, and to prevent "Cipher Errors" by hashing the current secret state.
commonLabels:
  kcspoc.io/managed-by: "kcspoc"
  kcspoc.io/config-hash: "$PROVISION_HASH_CONFIG"
  kcspoc.io/tool-version: "$PROVISION_VERSION_CONFIG"
  kcspoc.io/kcs-version: "2.1.1"

default:
  platform: "$PLATFORM_CONFIGURED"
  domain: "$DOMAIN_CONFIGURED"
  
  # --- [TEACHING POINT: THE mTLS BOOTSTRAP] ---
  # 'certSource: helm' signals the Chart to create Kubernetes 'Certificate' objects.
  # This triggers cert-manager to issue certs. Without this, pods hang in 'Init'.
  certSource: "helm"
  internalTLS:
    enabled: true
    certSource: "helm"
  certManager: true

  # --- [TEACHING POINT: UPDATES COMPONENT] ---
  # In 2.1.0, this was often ignored due to path issues. 2.1.1 strictly looks 
  # for this inside the 'default' block. Essential for vulnerability DB sync.
  updates:
    enabled: true

  # --- [TEACHING POINT: NETWORK POLICIES] ---
  # SECURITY: Isolates microservices. 
  # v2.1.1 FIX: You MUST define where the Ingress Controller lives (ingress-nginx)
  # or the Helm rendering engine will fail with a 'path does not exist' error.
  networkPolicies:
    create: true
    ingressControllerNamespaces:
      - ingress-nginx

  # Lab Optimization: We use 1 replica of IH to save memory. 
  # In Production, 3+ replicas are recommended for high-load image handling.
  kcs-ih:
    replicaCount: 1

  postgresql:
    resources:
      requests: { cpu: "100m", memory: "512Mi" }
      limits: { cpu: "500m", memory: "1Gi" }

nodeAgent:
  enabled: true
  runtimeSocketPath: "$CRI_SOCKET_CONFIG"
  installStrategy: DaemonSet

admissionController:
  enabled: true
  replicaCount: 1

configmap:
  infraconfig:
    type: fromEnvs
    envs:
      TLS_INTERNAL: true
      KUBE_AGENT_TAG: v2.1.1
      NODE_AGENT_TAG: v2.1.1
      SCANNER_TAG: v2.1.1
      IMAGE_TAG_MIDDLEWARE: v2.1.1

issuer:
  create: true
  name: kcs-issuer
  kind: Issuer
  selfSigned: true

pullSecret:
  kcs-pullsecret:
    registry: "$REGISTRY_SERVER_CONFIG"
    username: "$REGISTRY_USER_CONFIG"
    password: "$REGISTRY_PASS_CONFIG"
    email: "$REGISTRY_EMAIL_CONFIG"

ingress:
  kcs:
    domain: "$DOMAIN_CONFIGURED"
    ingressClass: "nginx"

persistentVolume:
  postgresql: { size: 20Gi }
  pvc-minio: { size: 5Gi }
  pvc-clickhouse-cold: { size: 40Gi }
  pvc-clickhouse-hot: { size: 20Gi }

secret:
  infracreds:
    type: fromEnvs
    envs:
      POSTGRES_USER: "$POSTGRES_USER_CONFIG"
      POSTGRES_PASSWORD: "$POSTGRES_PASS_CONFIG"
      MINIO_ROOT_USER: "$MINIO_USER_CONFIG"
      MINIO_ROOT_PASSWORD: "$MINIO_PASS_CONFIG"
      CLICKHOUSE_ADMIN_PASSWORD: "$CH_ADMIN_PASS_CONFIG"
      CLICKHOUSE_WRITE_PASSWORD: "$CH_WRITE_PASS_CONFIG"
      CLICKHOUSE_READ_PASSWORD: "$CH_READ_PASS_CONFIG"
      MCHD_USER: "$MCHD_USER_CONFIG"
      MCHD_PASS: "$MCHD_PASS_CONFIG"
      # --- [TEACHING POINT: THE MASTER KEY] ---
      # APP_SECRET is the encryption key for the DB. 
      # IF YOU CHANGE THIS on an existing cluster, you lose access to your data.
      APP_SECRET: "$APP_SECRET_CONFIG"